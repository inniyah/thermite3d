void ShadowMapReceiverForWorldVP(
	float4 inPosition		: POSITION,
	float4 inNormal		: NORMAL,
	//TODO - can we split the material between the last two elements of the position and normal?
	float2 inMaterial		  : TEXCOORD0,

	out float4 outPosition			: POSITION,
	out float4 outDiffuseLightColour		: COLOR,
	out float4 outShadowUV		: TEXCOORD0,
	out float4 outUV	   : TEXCOORD1,
	out float4 outNormal   : TEXCOORD2,
	out float2 outMaterial    : TEXCOORD3,

	uniform float4x4 world,
	uniform float4x4 worldIT,
	uniform float4x4 viewProj,
	uniform float4x4 texViewProj,
	uniform float4 lightPosition,
	uniform float4 lightColour,
	uniform float4 shadowDepthRange
	)
{	
	float4 worldPosition = mul(world, inPosition);	

	// Compute simple per-vertex lighting
	float3 worldNormal = mul(worldIT, inNormal).xyz;
	float3 lightDir = normalize(lightPosition.xyz -  (worldPosition.xyz * lightPosition.w));
	outDiffuseLightColour = lightColour * max(dot(lightDir, worldNormal), 0.0);	

	// calculate shadow map coords
	outShadowUV = mul(texViewProj, worldPosition);
	
	//Just pass though the normals without transforming them in any way.
	//No rotation occurs, and they are only used for the triplanar textureing anyway.
	outNormal = inNormal;
	
	//UV coordinates for triplanar texturing are taken directly from world position.
	outUV = worldPosition;

	outPosition = mul(viewProj, worldPosition);
	
	//Pass through the material
	outMaterial = inMaterial;
}

void ShadowMapReceiverForWorldFP(
	float4 inPosition			: POSITION,
	float4 inShadowUV			: TEXCOORD0,
	float4 inDiffuseLightColour		: COLOR,
	float4 inUV	   : TEXCOORD1,
	float4 inNormal   : TEXCOORD2,
	float2 inMaterial    : TEXCOORD3,
	
	uniform float4 ambientLightColour,

	uniform sampler2D shadowMap : TEXUNIT0,
	uniform sampler2D colourMap1 : TEXUNIT1,
	uniform sampler2D colourMap2 : TEXUNIT2,
	uniform sampler2D colourMap3 : TEXUNIT3,
	uniform sampler2D colourMap4 : TEXUNIT4,
	uniform sampler2D colourMap5 : TEXUNIT5,
	uniform sampler2D colourMap6 : TEXUNIT6,
	uniform sampler2D colourMap7 : TEXUNIT7,
	
	out float4 result		: COLOR)
{
	inUV /= 20.0f;
	
	float3 colourMapValueXY;
	float3 colourMapValueYZ;
	float3 colourMapValueXZ;
	
	inNormal *= inNormal;
	
	//FIXME - For some reason, precomputing the derivatives seemed to hurt performance.
	//But without doing it, Direct3D got wouldn't let me use more than two textures.
	//It appeared to be a bug...
	float2 uvDelta; uvDelta.x = ddx( inUV ).x; uvDelta.y = ddy( inUV ).y; 
	
	if(inMaterial.x < 0.5)
	{
		//Retrieve the 3 samples
		colourMapValueXY = float3(0.0,0.0,0.0);
		colourMapValueYZ = float3(0.0,0.0,0.0);
		colourMapValueXZ = float3(0.0,0.0,0.0);
	}	
	else if(inMaterial.x < 1.5)
	{
		//Retrieve the 3 samples
		colourMapValueXY = tex2D(colourMap1, inUV.xy, uvDelta.x, uvDelta.y).rgb * abs(inNormal.z);
		colourMapValueYZ = tex2D(colourMap1, inUV.yz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.x);
		colourMapValueXZ = tex2D(colourMap1, inUV.xz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.y);
	}
	else if(inMaterial.x < 2.5)
	{
		//Retrieve the 3 samples
		colourMapValueXY = tex2D(colourMap2, inUV.xy, uvDelta.x, uvDelta.y).rgb * abs(inNormal.z);
		colourMapValueYZ = tex2D(colourMap2, inUV.yz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.x);
		colourMapValueXZ = tex2D(colourMap2, inUV.xz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.y);
	}
	else if(inMaterial.x < 3.5)
	{
		//Retrieve the 3 samples
		colourMapValueXY = tex2D(colourMap3, inUV.xy, uvDelta.x, uvDelta.y).rgb * abs(inNormal.z);
		colourMapValueYZ = tex2D(colourMap3, inUV.yz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.x);
		colourMapValueXZ = tex2D(colourMap3, inUV.xz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.y);
	}
	else if(inMaterial.x < 4.5)
	{
		//Retrieve the 3 samples
		colourMapValueXY = tex2D(colourMap4, inUV.xy, uvDelta.x, uvDelta.y).rgb * abs(inNormal.z);
		colourMapValueYZ = tex2D(colourMap4, inUV.yz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.x);
		colourMapValueXZ = tex2D(colourMap4, inUV.xz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.y);
	}
	else if(inMaterial.x < 5.5)
	{
		//Retrieve the 3 samples
		colourMapValueXY = tex2D(colourMap5, inUV.xy, uvDelta.x, uvDelta.y).rgb * abs(inNormal.z);
		colourMapValueYZ = tex2D(colourMap5, inUV.yz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.x);
		colourMapValueXZ = tex2D(colourMap5, inUV.xz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.y);
	}
	else if(inMaterial.x < 6.5)
	{
		//Retrieve the 3 samples
		colourMapValueXY = tex2D(colourMap6, inUV.xy, uvDelta.x, uvDelta.y).rgb * abs(inNormal.z);
		colourMapValueYZ = tex2D(colourMap6, inUV.yz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.x);
		colourMapValueXZ = tex2D(colourMap6, inUV.xz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.y);
	}
	else if(inMaterial.x < 7.5)
	{
		//Retrieve the 3 samples
		colourMapValueXY = tex2D(colourMap7, inUV.xy, uvDelta.x, uvDelta.y).rgb * abs(inNormal.z);
		colourMapValueYZ = tex2D(colourMap7, inUV.yz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.x);
		colourMapValueXZ = tex2D(colourMap7, inUV.xz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.y);
	}
	else
	{
		//Retrieve the 3 samples
		colourMapValueXY = tex2D(colourMap1, inUV.xy, uvDelta.x, uvDelta.y).rgb * abs(inNormal.z);
		colourMapValueYZ = tex2D(colourMap1, inUV.yz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.x);
		colourMapValueXZ = tex2D(colourMap1, inUV.xz, uvDelta.x, uvDelta.y).rgb * abs(inNormal.y);
	}
	
	float4 colourMapValue = float4(colourMapValueXY + colourMapValueYZ + colourMapValueXZ, 1.0);
	colourMapValue *= inMaterial.y;
		
	// point on shadowmap
	inShadowUV = inShadowUV / inShadowUV.w;
	float centerdepth = tex2D(shadowMap, inShadowUV.xy).x;

	//float4 shadowVal = (centerdepth > shadowUV.z) ? vertexColour : float4(0,0,0,1);
	float4 lightColour = ambientLightColour;
	//if(centerdepth > inShadowUV.z)
	{
		lightColour += inDiffuseLightColour;
	}
	result = colourMapValue * lightColour;
	//result = (centerdepth > shadowUV.z) ? float4(0,0,0,1) : float4(0,0,0,1);
	//result = float4(1,0,0,1);
}